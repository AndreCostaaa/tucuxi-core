/*
* Copyright (C) 2017 Tucuxi SA
*/

#ifndef COMPUTINGRESPONSE_H
#define COMPUTINGRESPONSE_H

#include <string>
#include <vector>
#include <memory>

#include "tucucore/definitions.h"
#include "tucucore/dosage.h"

namespace Tucuxi {
namespace Core {


///
/// \brief The CycleData class, meant to embed data about a cycle
/// It contains concentrations and times for a single cycle (or interval)
class CycleData
{
public:
    CycleData() {}
    CycleData(const Tucuxi::Common::DateTime &_start, const Tucuxi::Common::DateTime &_end, const Unit &_unit)
        : m_start(_start), m_end(_end), m_unit(_unit)
    {
    }

    void addData(TimeOffsets &_offsets, std::vector<Concentration> _concentrations, Value _auc)
    {
        m_times.push_back(_offsets);
        m_concentrations.push_back(_concentrations);
        m_aucs.push_back(_auc);
    }

    /// \brief Absolute start time of the cycle
    Tucuxi::Common::DateTime m_start;

    /// \brief Absolute end time of the cycle
    /// This value could be computed from m_start and m_times, but it is more convenient
    /// To have it as a member variable
    Tucuxi::Common::DateTime m_end;

    /// \brief A serie of times exrpressed as offsets in millisecond to the start of a cycle
    std::vector<TimeOffsets> m_times;

    /// \brief A vector of vector of concentrations
    /// Each inner vector contains the concentrations of an analyte or a compartment
    /// The size of each inner vector has to be the same as m_times.
    std::vector< std::vector<Concentration> > m_concentrations;

    /// \brief Absolute end time of the cycle
    /// This value could be computed from m_start and m_times, but it is more convenient
    /// To have it as a member variable
    /// Area under curve for each prediction, in m_unit x hours
    std::vector<Value> m_aucs;

    /// \brief Unit of concentrations
    /// The area under curve corresponds to this unit times hours
    Unit m_unit;
};

///
/// \brief The SingleComputingResponse class is the base class for every response
/// It only contains an identifier
///
class SingleComputingResponse
{
public:
    SingleComputingResponse() = default;
    virtual ~SingleComputingResponse() = 0;
    RequestResponseId getId() const;

protected:

    SingleComputingResponse(RequestResponseId _id);

    RequestResponseId m_id;
};


///
/// \brief The SinglePointsResponse class
/// This class contains data generated by a ComputingTraitSinglePoints, that is
/// when values at specific times are asked by a request.
/// It is also the response for ComputingTraitAtMeasures, that calculates
/// points at the measure times found in the DrugTreatment.
/// Therefore it offers the absolute times corresponding to the request as well
/// as the calculated concentrations at these points.
///
class SinglePointsResponse : public SingleComputingResponse
{

    /// Absolute time of each concentration
    std::vector<Tucuxi::Common::DateTime> m_times;

    /// Concentration values
    std::vector<Concentrations> m_concentrations;

    /// Unit of concentrations
    Unit m_unit;
};

///
/// \brief The SinglePredictionResponse class
/// It contains data of a single prediction, as a vector of CycleData.
class SinglePredictionResponse : public SingleComputingResponse
{
public:
    SinglePredictionResponse() = default;
    void addCycleData(const CycleData &_data) { m_data.push_back(_data); }
    const std::vector<CycleData>& getData() { return m_data; }

private:
    std::vector<CycleData> m_data;
};

///
/// \brief The FullDosage class
/// This class embeds all information about a potential dosage adjustment:
/// The dosage history, the score (suitability of the dosage), and concentrations
/// if the concentrations have been calculated
///
class FullDosage
{
public:

    DosageHistory m_history;
    double m_score;
    std::vector<CycleData> m_data;
};

///
/// \brief The AdjustmentResponse class
/// This class embeds a vector of potential adjustments, each one being a
/// Dosage history, a score, and optionnally a concentration prediction.
///
class AdjustmentResponse : public SinglePredictionResponse
{

protected:

    /// A vector of possible dosage adjustments
    std::vector<FullDosage> m_adjustments;
};

///
/// \brief The PercentilesResponse class
/// It shall contain different percentiles, for a certain period of time.
/// In order to embed all data necessary for correct exploitation, it contains:
/// 1. The percentile ranks as a vector of doubles, each one being in [0.0,100.0]
/// 2. The concentration of percentiles, as a vector of CycleMultiData,
///    one CycleData per percentile
///
class PercentilesResponse : public SingleComputingResponse
{
public:

    void setRanks(const PercentileRanks &_ranks) { m_ranks = _ranks;}

    size_t getNbRanks() const { return m_ranks.size(); }

    PercentileRank getRank(unsigned int _index) const { return m_ranks.at(_index); }

    void addPercentileData(const std::vector<CycleData> &_data) { m_data.push_back(_data);}

    const CycleData& getData(unsigned int _percentileIndex, unsigned int _cycleIndex) const {
        return m_data.at(_percentileIndex).at(_cycleIndex);
    }

    const std::vector<CycleData>& getPercentileData(unsigned int _percentileIndex) const {
        return m_data.at(_percentileIndex);
    }

private:
    std::vector<std::vector<CycleData> > m_data;
    PercentileRanks m_ranks;
};



///
/// \brief The ComputingResponse class
/// It is the response to a ComputingRequest object. It has an identifier and
/// a vector of SingleComputingResponse, and as such can embed various responses,
/// like a prediction, various percentiles, and a dosage adjustment.
///
class ComputingResponse
{
public:
    ComputingResponse(RequestResponseId _id);

    RequestResponseId getId() const;
    void addResponse(std::unique_ptr<SingleComputingResponse> _response);

    const std::vector<std::unique_ptr<SingleComputingResponse> > & getResponses() const { return m_responses;}


protected:
    RequestResponseId m_id;
    std::vector<std::unique_ptr<SingleComputingResponse> > m_responses;

};

} // namespace Core
} // namespace Tucuxi

#endif // COMPUTINGRESPONSE_H
